---
title: "Graphical EDA I: continous data"
author:
- name: _Andronic Ioana-Larisa (Gr 405)_
- name: _Anastasiu Catalin-Gabriel (Gr 411)_
- name: _Sasu Catalin-Gabriel (Gr 405)_
date: "_`r format(Sys.time(), '%d %B %Y')`_"
output: 
  html_document:
    highlight: pygments
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(include = TRUE, echo = TRUE)
```

## **1. Examining Continuous Variables** 

## **2. Looking for Structure: Dependency Relationships and Associations** 

## **3. Investigating Multivariate Continuous Data**

### **3.1. Introduction**

#### Traditional methods used for displaying multivariate continous data:
- **scatterplots**. *Disadvantage:* only for bivariate data, not effective for exploring in higher dimensions;
- **matrices of scatterplots**. *Disadvantage:* do not really convey what multivariate structure there might be in the data;
- **dimension reduction methods (PCA, MDS, etc).** *Disadvantage:* they approximate the data, and it is difficult to assess how good the approximations are.

#### **New Method**: parallel coordinate plots. 
#### This solution has become popular for multivariate continuous data in recent years.

\

### **3.2. What is a parallel coordinate plot (pcp)?**

```{r fig.width=10,fig.height=5}
library('GGally'); data(food, package="MMST")
names(food) <- c("Fat", "Food.energy", "Carbohyd", "Protein", "Cholest", "Wt", "Satur.Fat")
# food1 <- food/food$Wt
food1 <- head(food, 10)/head(food, 10)$Wt
# TODO: sterge linia de deasupra si decomenteaza pe cealalta
# TODO: pt un plot mai plin si mai mult timp de asteptat la build
ggparcoord(data = food1, columns=c(1:5, 7), scale="uniminmax", alphaLines=0.2) + 
  xlab("") + ylab("")
```

#### In a parallel coordinate plot:
- all axes are parallel to one another;
- each variable has its own individual vertical axis (or alternatively all the axes are horizontal);
- each axis is usually scaled from the minimum to the maximum case values for the variable;
- each polygonal line across all axes defines a ***profile***.

\

#### **Functions for drawing pcp's in R**

| function       | package |
|----------------|---------|
| *ggparcoord*   | GGally  |
| *parcoord*     | MASS    |
| *cparcoord*    | gclus   |
| *pcp*          | PairViz |
| *parallelplot* | lattice |
| *parallel.ade* | epade   |
| *ipcp*         | iplots  |
| *...*          | ...     |

### **3.3. Features you can see with parallel coordinate plots**

#### Parallel coordinate plots are very useful for checking results like:
- outliers
- groups of cases with very similar values (**clusters**)
- bivariate associations between adjacent variables (**correlations**)
- gaps or concentrations of data
- skewness of univariate distributions for several variables at once

\

#### **Illustrating Fisherâ€™s iris dataset**
```{r fig.width=10,fig.height=5}
ggparcoord(iris, columns=1:4, groupColumn="Species")
```

### **3.4. Interpreting clustering results**

#### We can compare the clusters graphically with a pcp in which the clusters are given different colours.

#### In the **USArrests** dataset from 1973, the *Assault* variable separates the clusters, because it has a larger range of values than the other three variables.

```{r fig.width=10,fig.height=5}
hcav <- hclust(dist(USArrests), method="ave")
clu3 <- cutree(hcav, k=3)
clus <- factor(clu3)
usa1 <- cbind(USArrests, clus)
ggparcoord(usa1, columns=1:4, groupColumn="clus", scale="uniminmax") + 
  xlab("") + ylab("") + 
  theme(legend.position = "none") +
  geom_line(size = 1.1)
ggparcoord(usa1, columns=1:4, groupColumn="clus", scale="globalminmax") + 
  xlab("") + ylab("") + 
  theme(legend.position = "none") +
  geom_line(size = 1.1)
```

### **3.5. Parallel coordinate plots and time series**

#### In a parallel coordinate plot used for representing time series:
- each axis represents one of the time points;
- we cannot change the order of the axis;
- a common scaling is used for all axes (**scale**=*globalminmax*).

**Note:** *ipcp* method of **iplots** package is better for creating interactive time series pcp's.

\

#### **Illustrating the acres of corn planted by US states from 1866 to 2011**
```{r fig.width=10,fig.height=5}
library(reshape2); data(nass.corn, package="agridat")
c1 <- melt(nass.corn, id=c("year", "state"))
c1 <- within(c1, StateV <- interaction(state, variable))
c2 <- dcast(c1, StateV~year)
ggparcoord(subset(c2[1:48,], c2[1:48,147]> 250000), columns=2:147, groupColumn="StateV", scale="globalminmax") + 
  xlab("Year") + ylab("Acres") + 
  scale_x_discrete(breaks=seq(1865, 2015, 10)) + 
  theme(legend.position = "none")
```

### **3.6. Parallel coordinate plots for indices**

#### Usually, index values are weighted combinations of the values of their components. Examples:
- **stock market indices** - used to represent performances of groups of shares;
- **consumer price index** - summarises prices across a wide range of products;
- **average teaching score** - an overall index used for ranking universities in UK.

#### One way to represent them in pcp's:
- the index itself will have one axes associated;
- for each of the components there will be a seperate axes;
- the polygonal lines are the profiles of the individuals;
- more effective if some individuals or groups are identified by colour.

\

#### **Illustrating the Russell group from the *uniranks* dataset**
```{r fig.width=10,fig.height=5}
data(uniranks, package="GDAdata")
names(uniranks)[c(5, 6, 8, 10, 11, 13)] <- c("AvTeach", "NSSTeach", "SpendperSt", "Careers", "VAddScore", "NSSFeedb")
uniranks1 <- within(uniranks, StaffStu <- 1/(StudentStaffRatio))
uniranks2 <- within(uniranks1,
                    Rus <- ifelse(UniGroup=="Russell", "Russell", "not"))
ggparcoord(uniranks2[order(uniranks2$Rus, decreasing=FALSE),],
           columns=c(5:8, 10:14),
           order=c(5,12,8,9,14,6,13,7,11,10),
           groupColumn="Rus", scale="uniminmax") +
           xlab("") + ylab("") +
           theme(legend.position = "none",
           axis.ticks.y = element_blank(),
           axis.text.y = element_blank()) +
           scale_colour_manual(values = c("gray","red")) + 
           geom_line(size = 0.8)
```

### **3.7. Options for parallel coordinate plots**

#### **3.7.1. Alignment**

##### Instead of aligning the variables by their minimum and maximum values, they can be aligned by their *mean* or *median* with a corresponding adjustment to the minimum and maximum limits. This permits comparing the variability across variables better.

```{r fig.width=10,fig.height=5}
mz <- as.data.frame(apply(c2[1:48,2:147], 2,
                          function(x) x - mean(x,na.rm=TRUE)))
StateV <- c2[1:48,1]
mzA <- as.data.frame(cbind(StateV, mz))
ggparcoord(mzA, columns=2:147, scale="globalminmax", groupColumn="StateV") +
  xlab("Year") + ylab("Acres") +
  scale_x_discrete(breaks=seq(1865, 2015, 10)) +
  theme(legend.position = "none")
```

#### **3.7.2. Scaling**

##### Depending on the situation, there are different types of scaling:
- standardise each variable by substracting the *mean* and divinding by the *standard deviation* (**scale**=*std*)
- use the respective minimum and maximum values for each variable (**scale**=*uniminmax*)
- use a common scale so that the data will not be altered (**scale**=*globalminmax*)
- standardize vertical height and then center each varialbe around the *median* (**scale**=*center*, **scaleSummary**=*median*)

```{r fig.width=10,fig.height=5}
library('gridExtra'); data(body, package="gclus")
# body1 <- body
body1 = rbind(head(body, 10), tail(body, 10))
# TODO: sterge linia de deasupra si decomenteaza pe cealalta
# TODO: pt un plot mai plin si mai mult timp de asteptat la build
names(body1) <- abbreviate(names(body), 2)
names(body1)[c(4:5, 11:13, 19:21)] <- c("CDp", "CD", "Ch", "Ws", "Ab", "Cl", "An", "Wr")
a1 <- ggparcoord(body1, columns=1:24, alphaLines=0.1) + xlab("") + ylab("")
a2 <- ggparcoord(body1, columns=1:24, scale="uniminmax", alphaLines=0.1) + xlab("") + ylab("")
a3 <- ggparcoord(body1, columns=1:24, scale="globalminmax", alphaLines=0.1) + xlab("") + ylab("")
a4 <- ggparcoord(body1, columns=1:24, scale="center", scaleSummary="median", alphaLines=0.1) + xlab("") + ylab("")
grid.arrange(a1, a2, a3, a4)
```

#### **3.7.3. Outliers**

##### Sometimes we want to redraw the plot without showing the outliers. There are 3 ways:
- remove the cases with any outliers
- trim all outlier values to the chosen limits
- restrict the plot to the chosen limits

##### **Remove the cases with outliers (*food* dataset)**
```{r fig.width=10,fig.height=5}
fc <- function(xv) {
  bu <- boxplot(xv, plot=FALSE)$stats[5]
  cxv <- ifelse(xv > bu, NA, xv)
  bl <- boxplot(xv, plot=FALSE)$stats[1]
  cxv <- ifelse(cxv < bl, NA, cxv)
}
data(food, package="MMST")
food <- head(food, 30)
# TODO: sterge linia de deasupra
# TODO: pt un plot mai plin si mai mult timp de asteptat la build
rxfood <- as.data.frame(apply(food,2,fc))
ggparcoord(data = rxfood, columns = c(1:7), 
           scale="uniminmax", missing="exclude", 
           alphaLines=0.3) + xlab("") + ylab("")
```

##### **Trim all outliers to the chosen limits (*food* dataset)**
```{r fig.width=10,fig.height=5}
fb <- function(xv) {
  bu <- boxplot(xv, plot=FALSE)$stats[5]
  rxv <- ifelse(xv > bu, bu, xv)
  bl <- boxplot(xv, plot=FALSE)$stats[1]
  rxv <- ifelse(rxv < bl, bl, rxv)
}
data(food, package="MMST")
food <- head(food, 30)
# TODO: sterge linia de deasupra
# TODO: pt un plot mai plin si mai mult timp de asteptat la build
rfood <- as.data.frame(apply(food,2,fb))
ggparcoord(data = rfood, columns = c(1:7), 
           scale="uniminmax", alphaLines=0.3)
```

##### **Restrict the plot to the chosen limits (*food* dataset)**
```{r fig.width=10,fig.height=5}
fd <- function(xv) {
  bu <- boxplot(xv, plot=FALSE)$stats[5]
  bl <- boxplot(xv, plot=FALSE)$stats[1]
  dxv <- (xv - bl)/(bu - bl)
}
data(food, package="MMST")
food <- head(food, 30)
# TODO: sterge linia de deasupra
# TODO: pt un plot mai plin si mai mult timp de asteptat la build
rofood <- as.data.frame(apply(food,2,fd))
ggparcoord(data = rofood, columns = c(1:7)) + 
           coord_cartesian(ylim=c(0,1))
```

#### **3.7.4. Variable order**

##### **Order the axes by the F statistics from analyses of variance based on a grouping variable (as illustrated in *body* dataset)**

```{r fig.width=10,fig.height=5}
# data(body, package="gclus")
# body1 <- body
body1$Gn <- factor(body1$Gn)
ggparcoord(body1, columns=1:24, scale="uniminmax", 
           alphaLines=0.4, groupColumn="Gn",
           order="allClass") + xlab("") + ylab("") + 
           theme(legend.position = "none",
           axis.ticks.y = element_blank(),
           axis.text.y = element_blank())
```

- we can display two graphics, one for women and one for men, to avoid overplotting for the variables where the genders overlap.

```{r fig.width=10,fig.height=10}
a <- ggparcoord(body1[order(body1$Gn),], columns=c(1:24),
                groupColumn="Gn", order="allClass",
                scale="uniminmax") + xlab("") + ylab("") +
                theme(legend.position = "none",
                axis.ticks.y = element_blank(),
                axis.text.y = element_blank()) +
                scale_colour_manual(values = c("grey","#00BFC4"))
b <- ggparcoord(body1[order(body1$Gn, decreasing=TRUE),],
                columns=c(1:24), groupColumn="Gn", order="allClass",
                scale="uniminmax") + xlab("") + ylab("") +
                theme(legend.position = "none",
                axis.ticks.y = element_blank(),
                axis.text.y = element_blank()) +
                scale_colour_manual(values = c("#F8766D","grey"))
grid.arrange(a,b)
```

##### **Order the axes by their median values (*body* dataset)**

```{r fig.width=5,fig.height=5}
library('dplyr')
m2 <- apply(body[, 1:24], 2, median, na.rm=TRUE)
m2a <- order(m2)
ggparcoord(data = select(body, -Gender), alphaLines=0.3,
           scale="globalminmax", order=m2a) + coord_flip()
```


##### **Order the axes by their maximum values after standardization by mean and standard deviation (*body* dataset)**

```{r fig.width=10,fig.height=5}
B1 <- ggparcoord(data = body1, columns=c(1:24), scale="std")
B2 <- acast(B1$data[ ,c(2,4,5)], .ID ~ variable)
m4 <- apply(B2, 2, max, na.rm=TRUE)
m4r <- order(m4)
ggparcoord(data = body1, alphaLines=0.3,
           columns=c(1:24), scale="std", order=m4r)
```


#### **3.7.5. Formatting**

##### ***Type of display***
- by default cases are represented as polygonal lines;
- display individual points (**showPoints**=*TRUE*);
- plot boxplots for each variable (**boxplot**=*TRUE*).

##### ***Missings***
- by default exclude cases with any missings;
- impute missing values.

##### ***Aspect ratio***
- pcp's are best drawn wide and moderately high;
- usually the appropriate window size depends on the data.

##### ***Orientation***
- better to draw pcp's horizontally rather than vertically so that we can write 
variable names horizontally one above the other, avoiding overlapping texts.

##### ***Lines***
- their thickness can be varied;
- given the large number of lines, they should always be very thin;
- line colour and alpha-blending need more attention.

##### ***Colour***
- lines can be coloured in groups by a factor variable or on a continuous 
shading scale by a numeric variable;

```{r fig.width=10,fig.height=8}
data(Boston, package="MASS")
Boston <- head(Boston, 10)
# TODO: sterge linia de deasupra
# TODO: pt un plot mai plin si mai mult timp de asteptat la build
Boston1 <- within(Boston,
                  hmedv <- factor(ifelse(medv == 50,"Top", "Rest")))
Boston1 <- within(Boston1, mlevel <- ifelse(medv==50,1,0.1))
Boston1 <- within(Boston1, medv1 <- medv)
a <- ggparcoord(data = Boston1[order(Boston1$hmedv),],
                columns=c(1:14), groupColumn="hmedv",
                scale="uniminmax", alphaLines="mlevel",
                mapping = aes(size = 1)) + xlab("") + ylab("") +
                theme(axis.ticks.y = element_blank(),
                axis.text.y = element_blank())
b <- ggparcoord(data = Boston1, columns=c(1:14),
                groupColumn="medv1", scale="uniminmax") +
                xlab("") + ylab("") +
                theme(axis.ticks.y = element_blank(),
                axis.text.y = element_blank())
grid.arrange(a,b)
```

##### ***Alpha-blending***

The option **alphaLines** in *ggparcoord* can be used:

- to make some groups stand out more than others;
- to apply a user-specified variable in which the level of alpha-blending can be set for each case individually.

```{r fig.width=10,fig.height=5}
Boston1 <- Boston1 %>% mutate(
           arad = factor(ifelse(rad < max(rad), 0, 1)),
           aLevel = ifelse(rad < max(rad), 0.1, 1))
ggparcoord(data = Boston1, columns=c(1:14),
           scale="uniminmax", groupColumn= "arad",
           alphaLines="aLevel", order="allClass") +
           xlab("") + ylab("") +
           theme(legend.position = "none",
           axis.ticks.y = element_blank(),
           axis.text.y = element_blank())
```

### **3.8. Main points**

- Parallel coordinate plots are a **powerful multivariate display**, showing all continuous variables at once;

- There are many pcp **display options** in addition to the usual formatting options applicable to other graphics;

- Pcpâ€™s are helpful for exploring and evaluating the results of analyses such as **discriminant** or **cluster analyses**. They are also useful for checking multivariate **outliers**;

- Pcpâ€™s are an alternative means for presenting multiple regularly spaced **time series**;

- Pcpâ€™s are informative for displaying **indices** and their component parts together

- We should **draw several pcpâ€™s** to uncover the different features in a dataset (e.g. *food* dataset)

# THANK YOU!